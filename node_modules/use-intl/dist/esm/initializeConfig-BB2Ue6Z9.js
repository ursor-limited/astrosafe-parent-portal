import{memoize as e,strategies as t}from"@formatjs/fast-memoize";import n from"intl-messageformat";function r(e,t,n){return(t=function(e){var t=function(e,t){if("object"!=typeof e||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}let o=function(e){return e.MISSING_MESSAGE="MISSING_MESSAGE",e.MISSING_FORMAT="MISSING_FORMAT",e.ENVIRONMENT_FALLBACK="ENVIRONMENT_FALLBACK",e.INSUFFICIENT_PATH="INSUFFICIENT_PATH",e.INVALID_MESSAGE="INVALID_MESSAGE",e.INVALID_KEY="INVALID_KEY",e.FORMATTING_ERROR="FORMATTING_ERROR",e}({});class a extends Error{constructor(e,t){let n=e;t&&(n+=": "+t),super(n),r(this,"code",void 0),r(this,"originalMessage",void 0),this.code=e,t&&(this.originalMessage=t)}}function i(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.filter(Boolean).join(".")}function s(e){return i(e.namespace,e.key)}function l(e){console.error(e)}function u(n,r){return e(n,{cache:(o=r,{create:()=>({get:e=>o[e],set(e,t){o[e]=t}})}),strategy:t.variadic});var o}function c(e,t){return u((function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return new e(...n)}),t)}function m(){const e={dateTime:{},number:{},message:{},relativeTime:{},pluralRules:{},list:{},displayNames:{}},t=c(Intl.DateTimeFormat,e.dateTime),r=c(Intl.NumberFormat,e.number),o=c(Intl.PluralRules,e.pluralRules),a=c(Intl.RelativeTimeFormat,e.relativeTime),i=c(Intl.ListFormat,e.list),s=c(Intl.DisplayNames,e.displayNames),l=u((function(){return new n(arguments.length<=0?void 0:arguments[0],arguments.length<=1?void 0:arguments[1],arguments.length<=2?void 0:arguments[2],{formatters:{getNumberFormat:r,getDateTimeFormat:t,getPluralRules:o},...arguments.length<=3?void 0:arguments[3]})}),e.message);return{getDateTimeFormat:t,getNumberFormat:r,getPluralRules:o,getMessageFormat:l,getRelativeTimeFormat:a,getListFormat:i,getDisplayNames:s}}function g(e,t,n){Object.entries(e).forEach((e=>{let[r,o]=e;if(r.includes(".")){let e=r;n&&(e+=" (at ".concat(n,")")),t.push(e)}null!=o&&"object"==typeof o&&g(o,t,i(n,r))}))}function f(e,t){const n=[];g(e,n),n.length>0&&t(new a(o.INVALID_KEY,'Namespace keys can not contain the character "." as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid '.concat(1===n.length?"key":"keys",": ").concat(n.join(", "),'\n\nIf you\'re migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from "lodash";\n\nconst input = {\n  "one.one": "1.1",\n  "one.two": "1.2",\n  "two.one.one": "2.1.1"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   "one": {\n//     "one": "1.1",\n//     "two": "1.2"\n//   },\n//   "two": {\n//     "one": {\n//       "one": "2.1.1"\n//     }\n//   }\n// }\n')))}function I(e){let{getMessageFallback:t,messages:n,onError:r,...o}=e;const a=r||l,i=t||s;return n&&f(n,a),{...o,messages:n,onError:a,getMessageFallback:i}}export{a as I,o as a,s as b,m as c,l as d,I as i,i as j};
