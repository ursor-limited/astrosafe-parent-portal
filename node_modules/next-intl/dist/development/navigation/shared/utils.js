'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('../../shared/utils.js');

// Minor false positive: A route that has both optional and
// required params will allow optional params.

function normalizeNameOrNameWithParams(href) {
  // @ts-expect-error -- `extends string` in the generic unfortunately weakens the type
  return typeof href === 'string' ? {
    pathname: href
  } : href;
}
function serializeSearchParams(searchParams) {
  function serializeValue(value) {
    return String(value);
  }
  const urlSearchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(searchParams)) {
    if (Array.isArray(value)) {
      value.forEach(cur => {
        urlSearchParams.append(key, serializeValue(cur));
      });
    } else {
      urlSearchParams.set(key, serializeValue(value));
    }
  }
  return '?' + urlSearchParams.toString();
}
function compileLocalizedPathname(_ref) {
  let {
    pathname,
    locale,
    params,
    pathnames,
    query
  } = _ref;
  function getNamedPath(value) {
    let namedPath = pathnames[value];
    if (!namedPath) {
      namedPath = value;
    }
    return namedPath;
  }
  function compilePath(namedPath) {
    const template = typeof namedPath === 'string' ? namedPath : namedPath[locale];
    let compiled = template;
    if (params) {
      Object.entries(params).forEach(_ref2 => {
        let [key, value] = _ref2;
        let regexp, replacer;
        if (Array.isArray(value)) {
          regexp = "(\\[)?\\[...".concat(key, "\\](\\])?");
          replacer = value.map(v => String(v)).join('/');
        } else {
          regexp = "\\[".concat(key, "\\]");
          replacer = String(value);
        }
        compiled = compiled.replace(new RegExp(regexp, 'g'), replacer);
      });
    }

    // Clean up optional catch-all segments that were not replaced
    compiled = compiled.replace(/\[\[\.\.\..+\]\]/g, '');
    compiled = utils.normalizeTrailingSlash(compiled);
    if (compiled.includes('[')) {
      // Next.js throws anyway, therefore better provide a more helpful error message
      throw new Error("Insufficient params provided for localized pathname.\nTemplate: ".concat(template, "\nParams: ").concat(JSON.stringify(params)));
    }
    if (query) {
      compiled += serializeSearchParams(query);
    }
    return compiled;
  }
  if (typeof pathname === 'string') {
    const namedPath = getNamedPath(pathname);
    const compiled = compilePath(namedPath);
    return compiled;
  } else {
    const {
      pathname: href,
      ...rest
    } = pathname;
    const namedPath = getNamedPath(href);
    const compiled = compilePath(namedPath);
    const result = {
      ...rest,
      pathname: compiled
    };
    return result;
  }
}
function getRoute(locale, pathname, pathnames) {
  const sortedPathnames = utils.getSortedPathnames(Object.keys(pathnames));
  const decoded = decodeURI(pathname);
  for (const internalPathname of sortedPathnames) {
    const localizedPathnamesOrPathname = pathnames[internalPathname];
    if (typeof localizedPathnamesOrPathname === 'string') {
      const localizedPathname = localizedPathnamesOrPathname;
      if (utils.matchesPathname(localizedPathname, decoded)) {
        return internalPathname;
      }
    } else {
      if (utils.matchesPathname(localizedPathnamesOrPathname[locale], decoded)) {
        return internalPathname;
      }
    }
  }
  return pathname;
}
function getBasePath(pathname) {
  let windowPathname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.pathname;
  if (pathname === '/') {
    return windowPathname;
  } else {
    return windowPathname.replace(pathname, '');
  }
}

exports.compileLocalizedPathname = compileLocalizedPathname;
exports.getBasePath = getBasePath;
exports.getRoute = getRoute;
exports.normalizeNameOrNameWithParams = normalizeNameOrNameWithParams;
exports.serializeSearchParams = serializeSearchParams;
