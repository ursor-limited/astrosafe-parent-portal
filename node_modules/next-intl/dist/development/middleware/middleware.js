'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var server = require('next/server');
var constants = require('../shared/constants.js');
var utils$1 = require('../shared/utils.js');
var config = require('./config.js');
var getAlternateLinksHeaderValue = require('./getAlternateLinksHeaderValue.js');
var resolveLocale = require('./resolveLocale.js');
var syncCookie = require('./syncCookie.js');
var utils = require('./utils.js');

function createMiddleware(input) {
  const config$1 = config.receiveConfig(input);
  return function middleware(request) {
    var _config$domains;
    // Resolve potential foreign symbols (e.g. /ja/%E7%B4%84 → /ja/約))
    const unsafeExternalPathname = decodeURI(request.nextUrl.pathname);

    // Sanitize malicious URIs to prevent open redirect attacks due to
    // decodeURI doesn't escape encoded backslashes ('%5C' & '%5c')
    const externalPathname = utils.sanitizePathname(unsafeExternalPathname);
    const {
      domain,
      locale
    } = resolveLocale.default(config$1, request.headers, request.cookies, externalPathname);
    const hasMatchedDefaultLocale = domain ? domain.defaultLocale === locale : locale === config$1.defaultLocale;
    const domainsConfig = ((_config$domains = config$1.domains) === null || _config$domains === void 0 ? void 0 : _config$domains.filter(curDomain => utils.isLocaleSupportedOnDomain(locale, curDomain))) || [];
    const hasUnknownHost = config$1.domains != null && !domain;
    function rewrite(url) {
      const urlObj = new URL(url, request.url);
      if (request.nextUrl.basePath) {
        urlObj.pathname = utils.applyBasePath(urlObj.pathname, request.nextUrl.basePath);
      }
      const headers = new Headers(request.headers);
      headers.set(constants.HEADER_LOCALE_NAME, locale);
      return server.NextResponse.rewrite(urlObj, {
        request: {
          headers
        }
      });
    }
    function redirect(url, redirectDomain) {
      const urlObj = new URL(utils$1.normalizeTrailingSlash(url), request.url);
      if (domainsConfig.length > 0 && !redirectDomain) {
        const bestMatchingDomain = utils.getBestMatchingDomain(domain, locale, domainsConfig);
        if (bestMatchingDomain) {
          redirectDomain = bestMatchingDomain.domain;
          if (bestMatchingDomain.defaultLocale === locale && config$1.localePrefix.mode === 'as-needed') {
            urlObj.pathname = utils.getNormalizedPathname(urlObj.pathname, config$1.locales, config$1.localePrefix);
          }
        }
      }
      if (redirectDomain) {
        urlObj.host = redirectDomain;
        if (request.headers.get('x-forwarded-host')) {
          var _request$headers$get, _request$headers$get2;
          urlObj.protocol = (_request$headers$get = request.headers.get('x-forwarded-proto')) !== null && _request$headers$get !== void 0 ? _request$headers$get : request.nextUrl.protocol;
          urlObj.port = (_request$headers$get2 = request.headers.get('x-forwarded-port')) !== null && _request$headers$get2 !== void 0 ? _request$headers$get2 : '';
        }
      }
      if (request.nextUrl.basePath) {
        urlObj.pathname = utils.applyBasePath(urlObj.pathname, request.nextUrl.basePath);
      }
      return server.NextResponse.redirect(urlObj.toString());
    }
    const unprefixedExternalPathname = utils.getNormalizedPathname(externalPathname, config$1.locales, config$1.localePrefix);
    const pathnameMatch = utils.getPathnameMatch(externalPathname, config$1.locales, config$1.localePrefix);
    const hasLocalePrefix = pathnameMatch != null;
    const isUnprefixedRouting = config$1.localePrefix.mode === 'never' || hasMatchedDefaultLocale && config$1.localePrefix.mode === 'as-needed';
    let response;
    let internalTemplateName;
    let unprefixedInternalPathname = unprefixedExternalPathname;
    if (config$1.pathnames) {
      let resolvedTemplateLocale;
      [resolvedTemplateLocale, internalTemplateName] = utils.getInternalTemplate(config$1.pathnames, unprefixedExternalPathname, locale);
      if (internalTemplateName) {
        const pathnameConfig = config$1.pathnames[internalTemplateName];
        const localeTemplate = typeof pathnameConfig === 'string' ? pathnameConfig :
        // @ts-expect-error This is ok
        pathnameConfig[locale];
        if (utils$1.matchesPathname(localeTemplate, unprefixedExternalPathname)) {
          unprefixedInternalPathname = utils.formatTemplatePathname(unprefixedExternalPathname, localeTemplate, internalTemplateName);
        } else {
          let sourceTemplate;
          if (resolvedTemplateLocale) {
            // A localized pathname from another locale has matched
            sourceTemplate = typeof pathnameConfig === 'string' ? pathnameConfig :
            // @ts-expect-error This is ok
            pathnameConfig[resolvedTemplateLocale];
          } else {
            // An internal pathname has matched that
            // doesn't have a localized pathname
            sourceTemplate = internalTemplateName;
          }
          const localePrefix = isUnprefixedRouting ? undefined : utils$1.getLocalePrefix(locale, config$1.localePrefix);
          const template = utils.formatTemplatePathname(unprefixedExternalPathname, sourceTemplate, localeTemplate);
          response = redirect(utils.formatPathname(template, localePrefix, request.nextUrl.search));
        }
      }
    }
    if (!response) {
      if (unprefixedInternalPathname === '/' && !hasLocalePrefix) {
        if (isUnprefixedRouting) {
          response = rewrite(utils.formatPathname(unprefixedInternalPathname, utils.getLocaleAsPrefix(locale), request.nextUrl.search));
        } else {
          response = redirect(utils.formatPathname(unprefixedExternalPathname, utils$1.getLocalePrefix(locale, config$1.localePrefix), request.nextUrl.search));
        }
      } else {
        const internalHref = utils.formatPathname(unprefixedInternalPathname, utils.getLocaleAsPrefix(locale), request.nextUrl.search);
        if (hasLocalePrefix) {
          const externalHref = utils.formatPathname(unprefixedExternalPathname, pathnameMatch.prefix, request.nextUrl.search);
          if (config$1.localePrefix.mode === 'never') {
            response = redirect(utils.formatPathname(unprefixedExternalPathname, undefined, request.nextUrl.search));
          } else if (pathnameMatch.exact) {
            if (hasMatchedDefaultLocale && isUnprefixedRouting) {
              response = redirect(utils.formatPathname(unprefixedExternalPathname, undefined, request.nextUrl.search));
            } else {
              if (config$1.domains) {
                const pathDomain = utils.getBestMatchingDomain(domain, pathnameMatch.locale, domainsConfig);
                if ((domain === null || domain === void 0 ? void 0 : domain.domain) !== (pathDomain === null || pathDomain === void 0 ? void 0 : pathDomain.domain) && !hasUnknownHost) {
                  response = redirect(externalHref, pathDomain === null || pathDomain === void 0 ? void 0 : pathDomain.domain);
                } else {
                  response = rewrite(internalHref);
                }
              } else {
                response = rewrite(internalHref);
              }
            }
          } else {
            response = redirect(externalHref);
          }
        } else {
          if (isUnprefixedRouting) {
            response = rewrite(internalHref);
          } else {
            response = redirect(utils.formatPathname(unprefixedExternalPathname, utils$1.getLocalePrefix(locale, config$1.localePrefix), request.nextUrl.search));
          }
        }
      }
    }
    if (config$1.localeDetection) {
      syncCookie.default(request, response, locale);
    }
    if (config$1.localePrefix.mode !== 'never' && config$1.alternateLinks && config$1.locales.length > 1) {
      var _config$pathnames;
      response.headers.set('Link', getAlternateLinksHeaderValue.default({
        config: config$1,
        localizedPathnames: internalTemplateName != null ? (_config$pathnames = config$1.pathnames) === null || _config$pathnames === void 0 ? void 0 : _config$pathnames[internalTemplateName] : undefined,
        request,
        resolvedLocale: locale
      }));
    }
    return response;
  };
}

exports.default = createMiddleware;
