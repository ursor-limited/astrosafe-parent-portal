import{getSortedPathnames as t,matchesPathname as n,normalizeTrailingSlash as r}from"../../shared/utils.js";function e(t){return"string"==typeof t?{pathname:t}:t}function o(t){function n(t){return String(t)}const r=new URLSearchParams;for(const[e,o]of Object.entries(t))Array.isArray(o)?o.forEach((t=>{r.append(e,n(t))})):r.set(e,n(o));return"?"+r.toString()}function a(t){let{pathname:n,locale:e,params:a,pathnames:c,query:i}=t;function s(t){let n=c[t];return n||(n=t),n}function f(t){const n="string"==typeof t?t:t[e];let c=n;if(a&&Object.entries(a).forEach((t=>{let n,r,[e,o]=t;Array.isArray(o)?(n="(\\[)?\\[...".concat(e,"\\](\\])?"),r=o.map((t=>String(t))).join("/")):(n="\\[".concat(e,"\\]"),r=String(o)),c=c.replace(new RegExp(n,"g"),r)})),c=c.replace(/\[\[\.\.\..+\]\]/g,""),c=r(c),c.includes("["))throw new Error("Insufficient params provided for localized pathname.\nTemplate: ".concat(n,"\nParams: ").concat(JSON.stringify(a)));return i&&(c+=o(i)),c}if("string"==typeof n){return f(s(n))}{const{pathname:t,...r}=n;return{...r,pathname:f(s(t))}}}function c(r,e,o){const a=t(Object.keys(o)),c=decodeURI(e);for(const t of a){const e=o[t];if("string"==typeof e){if(n(e,c))return t}else if(n(e[r],c))return t}return e}function i(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.pathname;return"/"===t?n:n.replace(t,"")}export{a as compileLocalizedPathname,i as getBasePath,c as getRoute,e as normalizeNameOrNameWithParams,o as serializeSearchParams};
